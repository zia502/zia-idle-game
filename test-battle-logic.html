<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>战斗逻辑测试</title>
    <style>
        body { font-family: sans-serif; margin: 20px; }
        .test-case { margin-bottom: 15px; border: 1px solid #ccc; padding: 10px; }
        .test-case h3 { margin-top: 0; }
        .pass { color: green; }
        .fail { color: red; }
        pre { background-color: #f0f0f0; padding: 10px; border-radius: 5px; white-space: pre-wrap; word-wrap: break-word; }
    </style>
</head>
<body>
    <h1>战斗逻辑测试</h1>
    <div id="test-results"></div>

    <script>
        // 辅助函数，用于在页面上显示测试结果
        function logResult(testName, passed, details = '') {
            const resultsDiv = document.getElementById('test-results');
            const testDiv = document.createElement('div');
            testDiv.className = 'test-case';
            let html = `<h3>${testName}</h3>`;
            if (passed) {
                html += '<p class="pass">通过</p>';
            } else {
                html += '<p class="fail">失败</p>';
            }
            if (details) {
                html += `<pre>${escapeHtml(details)}</pre>`;
            }
            testDiv.innerHTML = html;
            resultsDiv.appendChild(testDiv);
            console.log(`${testName}: ${passed ? 'PASS' : 'FAIL'}`, details);
        }

        function escapeHtml(unsafe) {
            if (typeof unsafe !== 'string') {
                try {
                    unsafe = JSON.stringify(unsafe, null, 2);
                } catch (e) {
                    unsafe = String(unsafe);
                }
            }
            return unsafe
                .replace(/&/g, "&")
                .replace(/</g, "<")
                .replace(/>/g, ">")
                .replace(/"/g, String.fromCharCode(34))
                .replace(/'/g, String.fromCharCode(39));
        }

        // 模拟依赖对象 (如果需要)
        const MockCharacter = {
            characters: {},
            getCharacter: function(id) {
                console.log(`%c[MOCK_CHARACTER_GET_CHARACTER_INVOKED] ID: "${id}"`, "color: lime; font-weight: bold;");
                const charKeys = Object.keys(this.characters);
                console.log(`[MockCharacter.getCharacter] 当前 MockCharacter.characters 键 (${charKeys.length}个): ${charKeys.join(', ')}`);
                const found = this.characters[id];
                if (!found) {
                    console.error(`[MockCharacter.getCharacter] 未找到角色 ID: "${id}". this.characters["${id}"] is ${this.characters[id]}`);
                } else {
                    console.log(`[MockCharacter.getCharacter] 找到角色 ID: "${id}", Name: ${found.name}`);
                }
                return found || null;
            },
            calculateAttackPower: function(character) {
                return character.currentStats.attack || 50;
            },
            // ... 其他模拟方法
            traits: {},
            assessBattleMVP: function(memberIds) {
                if (!memberIds || memberIds.length === 0) return { mvpId: null, score: 0 };
                let mvpId = null;
                let maxDamage = -1;
                memberIds.forEach(id => {
                    const char = this.getCharacter(id);
                    if (char && char.stats && char.stats.totalDamage > maxDamage) {
                        maxDamage = char.stats.totalDamage;
                        mvpId = id;
                    }
                });
                return { mvpId: mvpId, score: maxDamage };
            }
        };
        // window.Character = MockCharacter; // Will be moved to onload

        const MockSkillLoader = {
            skills: {},
            getSkillInfo: function(skillId) {
                return this.skills[skillId] || null;
            }
        };
        window.SkillLoader = MockSkillLoader;

        const MockJobSkills = {
            lastCallArgs: null, // 用于记录最后一次调用的参数
            useSkill: function(caster, skillId, teamMembers, monster, isCasterPlayer) { // 更新参数以匹配实际的 job-skills.js
                this.lastCallArgs = { caster, skillId, teamMembers, monster, isCasterPlayer }; // 记录参数
                
                const skillData = SkillLoader.getSkillInfo(skillId);
                if (!caster || !skillData) return { success: false, message: "施法者或技能数据未找到" };

                // 模拟 getTargets 的核心逻辑，以便测试中断言
                let actualTargets = [];
                const targetType = skillData.targetType;

                if (isCasterPlayer) { // 施法者是玩家
                    if (targetType === 'all_enemies' && monster && monster.currentStats.hp > 0) {
                        actualTargets = [monster];
                    } else if (targetType === 'single_enemy' && monster && monster.currentStats.hp > 0) {
                        actualTargets = [monster]; // 简化，总是选择主怪物
                    } else if (targetType === 'all_allies') {
                        actualTargets = teamMembers.filter(m => m.currentStats.hp > 0);
                    } else if (targetType === 'single_ally') {
                        actualTargets = teamMembers.length > 0 ? [teamMembers[0]] : []; // 简化，选择第一个队友
                    } else if (targetType === 'self') {
                        actualTargets = [caster];
                    }
                } else { // 施法者是怪物
                    if (targetType === 'all_enemies') { // 对于怪物，all_enemies 指的是玩家队伍
                        actualTargets = teamMembers.filter(m => m.currentStats.hp > 0);
                    } else if (targetType === 'single_enemy') { // 对于怪物，single_enemy 指的是玩家队伍中的一个
                        actualTargets = teamMembers.length > 0 ? [teamMembers[0]] : []; // 简化，选择第一个玩家
                    } else if (targetType === 'all_allies' && monster && monster.currentStats.hp > 0) { // 怪物对自己用 all_allies (通常是单体)
                        actualTargets = [caster]; // 怪物对自己用
                    } else if (targetType === 'single_ally' && monster && monster.currentStats.hp > 0) {
                        actualTargets = [caster]; // 怪物对自己用
                    }
                }
                this.lastCallArgs.determinedTargets = actualTargets; // 记录模拟的 getTargets 结果

                let message = `${caster.name} 使用技能 ${skillData.name}。`;
                let totalDamage = 0;

                // 模拟技能效果 (基于 actualTargets)
                if (skillData.effects) {
                    skillData.effects.forEach(effect => {
                        if (effect.type === 'damage') {
                            const damage = (effect.value || 50) * (effect.multiplier || 1);
                            actualTargets.forEach(target => {
                                if (target && target.currentStats && target.currentStats.hp > 0) {
                                    target.currentStats.hp -= damage;
                                    totalDamage += damage;
                                    message += ` 对 ${target.name} 造成 ${damage} 伤害。`;
                                    if (target.currentStats.hp <= 0) {
                                        target.currentStats.hp = 0;
                                        message += ` ${target.name} 被击败。`;
                                    }
                                }
                            });
                        } else if (effect.type === 'heal') {
                            const heal = effect.value || 30;
                             actualTargets.forEach(target => {
                                if (target && target.currentStats && target.currentStats.hp > 0) {
                                    target.currentStats.hp += heal;
                                    if (target.currentStats.hp > target.currentStats.maxHp) {
                                        target.currentStats.hp = target.currentStats.maxHp;
                                    }
                                    message += ` 为 ${target.name} 恢复 ${heal} HP。`;
                                }
                            });
                        } else if (effect.type === 'applyBuff' && BuffSystem) {
                            actualTargets.forEach(target => {
                                if (target && target.currentStats && target.currentStats.hp > 0) {
                                    const buff = BuffSystem.createBuff(effect.buffType, effect.value, effect.duration, caster);
                                    if (buff) {
                                        BuffSystem.applyBuff(target, buff);
                                        message += ` 为 ${target.name} 施加了 ${buff.name}。`;
                                    }
                                }
                            });
                        }
                    });
                }
                // 模拟消耗资源
                if (skillData.cost && caster.currentStats.mp) {
                    caster.currentStats.mp -= skillData.cost;
                }
                // 模拟冷却
                if (caster.skillCooldowns && skillData.cooldown !== undefined) { // 确保 cooldown 存在
                    caster.skillCooldowns[skillId] = skillData.cooldown;
                }

                return { success: true, message: message, damageDealt: totalDamage, appliedEffects: actualTargets.length > 0 };
            }
        };
        window.JobSkills = MockJobSkills;

        const MockJobSkillsTemplate = { // 添加这个模拟对象
            templates: {}
        };
        window.JobSkillsTemplate = MockJobSkillsTemplate;


        const MockBuffSystem = {
            buffsData: { // 模拟一些buff定义
                'atk_up_s': { id: 'atk_up_s', name: '攻击提升(小)', type: 'statBuff', stat: 'attack', value: 20, duration: 3, isPositive: true, canDispel: true },
                'def_down_s': { id: 'def_down_s', name: '防御下降(小)', type: 'statBuff', stat: 'defense', value: -20, duration: 2, isPositive: false, canDispel: true },
                'stun': { id: 'stun', name: '眩晕', type: 'stun', duration: 1, isPositive: false, canDispel: true },
                'poison': { id: 'poison', name: '中毒', type: 'dot', damage: 10, duration: 3, isPositive: false, canDispel: true },
                'regen': { id: 'regen', name: '再生', type: 'hot', heal: 15, duration: 2, isPositive: true, canDispel: true },
                'silence': { id: 'silence', name: '沉默', type: 'silence', duration: 2, isPositive: false, canDispel: true },
            },
            createBuff: function(buffIdOrType, value, duration, source, options = {}) {
                const buffData = this.buffsData[buffIdOrType] || {
                    id: buffIdOrType,
                    name: buffIdOrType,
                    type: buffIdOrType,
                    value: value,
                    duration: duration,
                    sourceId: source ? source.id : null,
                    isPositive: options.isPositive !== undefined ? options.isPositive : true,
                    canDispel: options.canDispel !== undefined ? options.canDispel : true,
                    ...options
                };
                return { ...buffData, currentDuration: duration, uniqueId: Date.now() + Math.random() }; // 确保唯一性
            },
            applyBuff: function(target, buff) {
                if (!target.buffs) target.buffs = [];
                // 简单叠加，不处理复杂逻辑
                target.buffs.push(buff);
                // 立即应用属性变化 (简化)
                if (buff.type === 'statBuff' && target.currentStats[buff.stat] !== undefined) {
                    target.currentStats[buff.stat] += buff.value;
                }
            },
            removeBuff: function(target, buffIdToRemove) { // uniqueId
                if (!target.buffs) return false;
                const index = target.buffs.findIndex(b => b.uniqueId === buffIdToRemove);
                if (index > -1) {
                    const buff = target.buffs[index];
                    // 移除属性变化 (简化)
                    if (buff.type === 'statBuff' && target.currentStats[buff.stat] !== undefined) {
                        target.currentStats[buff.stat] -= buff.value;
                    }
                    target.buffs.splice(index, 1);
                    return true;
                }
                return false;
            },
            updateBuffDurations: function(entity) {
                if (!entity.buffs) return [];
                const expiredBuffs = [];
                for (let i = entity.buffs.length - 1; i >= 0; i--) {
                    const buff = entity.buffs[i];
                    buff.currentDuration--;
                    if (buff.currentDuration <= 0) {
                        expiredBuffs.push(buff);
                        this.removeBuff(entity, buff.uniqueId); // 使用 uniqueId
                    }
                }
                return expiredBuffs;
            },
            processBuffsAtTurnStart: function(entity) {
                let damage = 0;
                let healing = 0;
                if (entity.buffs) {
                    entity.buffs.forEach(buff => {
                        if (buff.type === 'dot' && buff.currentDuration > 0) damage += buff.damage;
                        if (buff.type === 'hot' && buff.currentDuration > 0) healing += buff.heal;
                    });
                }
                return { damage, healing };
            },
            clearAllBuffs: function(entity) {
                if (entity.buffs) {
                    for (let i = entity.buffs.length - 1; i >= 0; i--) {
                        this.removeBuff(entity, entity.buffs[i].uniqueId);
                    }
                }
                entity.buffs = [];
            },
            getBuffsByType: function(entity, buffType) {
                if (!entity || !entity.buffs) return [];
                return entity.buffs.filter(buff => buff.type === buffType);
            }
        };
        window.BuffSystem = MockBuffSystem;

        const MockEvents = {
            listeners: {},
            emit: function(eventName, data) {
                // console.log(`Event emitted: ${eventName}`, data);
                if (this.listeners[eventName]) {
                    this.listeners[eventName].forEach(callback => callback(data));
                }
            },
            on: function(eventName, callback) {
                if (!this.listeners[eventName]) {
                    this.listeners[eventName] = [];
                }
                this.listeners[eventName].push(callback);
            }
        };
        window.Events = MockEvents;

        const MockDungeon = { // 模拟 Dungeon 对象
            currentRun: null // 或 true/false 根据测试需要设置
        };
        window.Dungeon = MockDungeon;

        const MockJobSystem = { // 模拟 JobSystem
            getSkill: function(skillId) {
                return SkillLoader.getSkillInfo(skillId); // 复用 SkillLoader 的模拟
            }
        };
        window.JobSystem = MockJobSystem;

        // 占位符，如果 battle.js 内部有 UI 更新逻辑
        const MockMainUI = {
            updateBattleLog: function() { /* console.log("MockMainUI.updateBattleLog called"); */ }
        };
        window.MainUI = MockMainUI;


        // --- 模拟数据定义 ---
        let player1, player2, player3, player_front1, player_front2, player_back1, player_back2, monster1, monster_aoe_user;
        let team, teamOfThree, teamWithBackline, battleInstance;

        function setupMockData() {
            // 确保每次 setup 时，全局 Character 都指向我们的 Mock
            if (typeof Character !== 'undefined' && window.Character !== MockCharacter) {
                 console.warn("[setupMockData] window.Character 不是 MockCharacter，强制覆盖。");
                 window.Character = MockCharacter;
            } else if (typeof Character === 'undefined') {
                 console.warn("[setupMockData] window.Character 未定义，设置为 MockCharacter。");
                 window.Character = MockCharacter;
            }
            // 即使 window.Character 已经是 MockCharacter，也确保其内部 characters 对象被正确重置和填充
            MockCharacter.characters = {}; // 清空之前的角色数据
            
            MockSkillLoader.skills = { // 清空并重新定义技能
                'skill_attack_single': { id: 'skill_attack_single', name: '强力一击', type: 'attack', targetType: 'single_enemy', effects: [{ type: 'damage', value: 100 }], cost: 10, cooldown: 2, initialCooldown: 0 },
                'skill_heal_single': { id: 'skill_heal_single', name: '治疗术', type: 'heal', targetType: 'single_ally', effects: [{ type: 'heal', value: 80 }], cost: 15, cooldown: 3, initialCooldown: 1 },
                'skill_buff_self': { id: 'skill_buff_self', name: '自我强化', type: 'buff', targetType: 'self', effects: [{ type: 'applyBuff', buffType: 'atk_up_s', duration: 3 }], cost: 5, cooldown: 4 },
                'skill_player_aoe_enemies': { id: 'skill_player_aoe_enemies', name: '玩家群体攻击敌方', type: 'attack', targetType: 'all_enemies', effects: [{ type: 'damage', value: 60 }], cost: 20, cooldown: 3 },
                'skill_player_aoe_allies': { id: 'skill_player_aoe_allies', name: '玩家群体治疗友方', type: 'heal', targetType: 'all_allies', effects: [{ type: 'heal', value: 40 }], cost: 20, cooldown: 3 },
                'skill_monster_aoe_player': { id: 'skill_monster_aoe_player', name: '怪物群体攻击玩家', type: 'attack', targetType: 'all_enemies', effects: [{ type: 'damage', value: 70 }], cost: 0, cooldown: 1 }, // 怪物用 all_enemies 指玩家
                'skill_debuff_enemy': { id: 'skill_debuff_enemy', name: '削弱敌人', type: 'debuff', targetType: 'single_enemy', effects: [{ type: 'applyBuff', buffType: 'def_down_s', duration: 2 }], cost: 10, cooldown: 2 },
                'skill_stun_enemy': { id: 'skill_stun_enemy', name: '眩晕打击', type: 'control', targetType: 'single_enemy', effects: [{ type: 'applyBuff', buffType: 'stun', duration: 1 }], cost: 25, cooldown: 5 },
                'skill_passive_regen': { id: 'skill_passive_regen', name: '被动再生', passive: true, effects: [{ type: 'proc', triggerCondition: 'onTurnEnd', chance: 1.0, triggeredEffects: [{ type: 'heal', targetType: 'self', value: 10 }] }] },
                'skill_no_cost_quick': { id: 'skill_no_cost_quick', name: '迅捷打击', type: 'attack', targetType: 'single_enemy', effects: [{ type: 'damage', value: 30 }], cost: 0, cooldown: 0 },
                'skill_high_cooldown': { id: 'skill_high_cooldown', name: '终极爆发', type: 'attack', targetType: 'single_enemy', effects: [{ type: 'damage', value: 500 }], cost: 50, cooldown: 10, initialCooldown: 3 },
                'skill_silence_enemy': { id: 'skill_silence_enemy', name: '沉默术', type: 'control', targetType: 'single_enemy', effects: [{ type: 'applyBuff', buffType: 'silence', duration: 2 }], cost: 15, cooldown: 4 },
                'skill_monster_single_ally_buff': { id: 'skill_monster_single_ally_buff', name: '怪物自我强化', type: 'buff', targetType: 'single_ally', effects: [{ type: 'applyBuff', buffType: 'atk_up_s', duration: 2 }], cost: 0, cooldown: 2}, // 怪物用 single_ally 指自己
                'skill_backline_attack': { id: 'skill_backline_attack', name: '后援打击', type: 'attack', targetType: 'single_enemy', effects: [{ type: 'damage', value: 75 }], cost: 5, cooldown: 1 }
            };
            // 将技能也加载到 JobSkillsTemplate (因为 battle.js 中有这样的调用)
            MockJobSkillsTemplate.templates = { ...MockSkillLoader.skills };


            player1 = {
                id: 'player1', name: '勇者', level: 10, isPlayer: true,
                baseStats: { hp: 200, maxHp: 200, mp: 100, maxMp: 100, attack: 50, defense: 30, speed: 40, daRate: 0.1, taRate: 0.05 },
                currentStats: { hp: 200, maxHp: 200, mp: 100, maxMp: 100, attack: 50, defense: 30, speed: 40, daRate: 0.1, taRate: 0.05 },
                skills: ['skill_attack_single', 'skill_buff_self', 'skill_passive_regen', 'skill_player_aoe_enemies', 'skill_player_aoe_allies'],
                buffs: [], skillCooldowns: {}, skillUsageCount: {}, stats: { totalDamage: 0, totalHealing: 0, daCount: 0, taCount: 0, critCount: 0 },
                originalStats: {}, weaponBonusStats: { hp: 200, maxHp: 200, mp: 100, maxMp: 100, attack: 50, defense: 30, speed: 40, daRate: 0.1, taRate: 0.05 }
            };
            player2 = {
                id: 'player2', name: '法师', level: 10, isPlayer: true,
                baseStats: { hp: 150, maxHp: 150, mp: 150, maxMp: 150, attack: 30, defense: 20, speed: 50, daRate: 0.05, taRate: 0.02 },
                currentStats: { hp: 150, maxHp: 150, mp: 150, maxMp: 150, attack: 30, defense: 20, speed: 50, daRate: 0.05, taRate: 0.02 },
                skills: ['skill_heal_single', 'skill_stun_enemy'],
                buffs: [], skillCooldowns: {}, skillUsageCount: {}, stats: { totalDamage: 0, totalHealing: 0, daCount: 0, taCount: 0, critCount: 0 },
                originalStats: {}, weaponBonusStats: { hp: 150, maxHp: 150, mp: 150, maxMp: 150, attack: 30, defense: 20, speed: 50, daRate: 0.05, taRate: 0.02 }
            };
            player3 = { // 新增 player3
                id: 'player3', name: '牧师', level: 10, isPlayer: true,
                baseStats: { hp: 180, maxHp: 180, mp: 120, maxMp: 120, attack: 25, defense: 25, speed: 35, daRate: 0.03, taRate: 0.01 },
                currentStats: { hp: 180, maxHp: 180, mp: 120, maxMp: 120, attack: 25, defense: 25, speed: 35, daRate: 0.03, taRate: 0.01 },
                skills: ['skill_heal_single'],
                buffs: [], skillCooldowns: {}, skillUsageCount: {}, stats: { totalDamage: 0, totalHealing: 0, daCount: 0, taCount: 0, critCount: 0 },
                originalStats: {}, weaponBonusStats: { hp: 180, maxHp: 180, mp: 120, maxMp: 120, attack: 25, defense: 25, speed: 35, daRate: 0.03, taRate: 0.01 }
            };
            // For backline tests
            player_front1 = {
                id: 'pf1', name: '前锋甲', level: 10, isPlayer: true,
                baseStats: { hp: 100, maxHp: 100, attack: 60, speed: 60 }, currentStats: { hp: 100, maxHp: 100, attack: 60, speed: 60 },
                skills: ['skill_attack_single'], buffs: [], skillCooldowns: {}, stats: { totalDamage: 0 }
            };
            player_front2 = {
                id: 'pf2', name: '前锋乙', level: 10, isPlayer: true,
                baseStats: { hp: 120, maxHp: 120, attack: 55, speed: 55 }, currentStats: { hp: 120, maxHp: 120, attack: 55, speed: 55 },
                skills: ['skill_attack_single'], buffs: [], skillCooldowns: {}, stats: { totalDamage: 0 }
            };
            player_back1 = {
                id: 'pb1', name: '后援甲', level: 10, isPlayer: true,
                baseStats: { hp: 150, maxHp: 150, attack: 40, speed: 30 }, currentStats: { hp: 70, maxHp: 150, attack: 40, speed: 30 }, // HP不满
                skills: ['skill_backline_attack'], buffs: [], skillCooldowns: {}, stats: { totalDamage: 0 }
            };
            player_back2 = {
                id: 'pb2', name: '后援乙', level: 10, isPlayer: true,
                baseStats: { hp: 160, maxHp: 160, attack: 45, speed: 25 }, currentStats: { hp: 160, maxHp: 160, attack: 45, speed: 25 }, // 满HP
                skills: ['skill_backline_attack'], buffs: [], skillCooldowns: {}, stats: { totalDamage: 0 }
            };

            MockCharacter.characters['player1'] = player1;
            MockCharacter.characters['player2'] = player2;
            MockCharacter.characters['player3'] = player3;
            MockCharacter.characters['pf1'] = player_front1;
            MockCharacter.characters['pf2'] = player_front2;
            MockCharacter.characters['pb1'] = player_back1;
            MockCharacter.characters['pb2'] = player_back2;


            monster1 = {
                id: 'monster1', name: '哥布林', level: 8, type: 'attack', attribute: 'dark', isPlayer: false,
                baseStats: { hp: 300, maxHp: 300, attack: 40, defense: 20, speed: 30 },
                currentStats: { hp: 300, maxHp: 300, attack: 40, defense: 20, speed: 30 },
                skills: ['skill_attack_single'],
                buffs: [], skillCooldowns: {}, skillUsageCount: {}, stats: { totalDamage: 0, totalHealing: 0 },
                isBoss: false
            };
            monster_aoe_user = { // 新增使用AoE的怪物
                id: 'monster_aoe', name: '史莱姆王', level: 10, type: 'magic', attribute: 'water', isPlayer: false,
                baseStats: { hp: 500, maxHp: 500, attack: 30, defense: 10, speed: 25 },
                currentStats: { hp: 500, maxHp: 500, attack: 30, defense: 10, speed: 25 },
                skills: ['skill_monster_aoe_player', 'skill_monster_single_ally_buff'],
                buffs: [], skillCooldowns: {}, skillUsageCount: {}, stats: { totalDamage: 0, totalHealing: 0 },
                isBoss: true // 假设它是Boss
            };
            MockCharacter.characters['monster1'] = monster1;
            MockCharacter.characters['monster_aoe_user'] = monster_aoe_user;

            // 确保怪物的 hp 和 maxHp 在 currentStats 中
            Object.values(MockCharacter.characters).forEach(char => {
                if (char && char.baseStats && char.currentStats ) { // 移除 !char.isPlayer 检查，确保所有角色都初始化
                    char.currentStats.hp = char.baseStats.hp; // 默认满血
                    char.currentStats.maxHp = char.baseStats.maxHp;
                    // 如果是后排测试角色，则按其定义设置初始HP
                    if (char.id === 'pb1') char.currentStats.hp = 70;
                }
            });


            team = { id: 'team1', name: '玩家小队', members: ['player1', 'player2'] };
            teamOfThree = { id: 'team2', name: '三人小队', members: ['player1', 'player2', 'player3'] };
            teamWithBackline = { id: 'team_backline', name: '后援小队', members: ['pf1', 'pf2', 'pb1', 'pb2'] };


            // Battle 对象在 battle.js 中定义，这里直接使用
            battleInstance = window.Battle; // Battle is globally available from battle.js
            battleInstance.reset(); // 重置战斗状态
            MockJobSkills.lastCallArgs = null; // 重置 MockJobSkills 的记录
            console.log(`[setupMockData] 完成. MockCharacter.characters 键 (${Object.keys(MockCharacter.characters).length}个): ${Object.keys(MockCharacter.characters).join(', ')}`);
        }

        // --- 测试用例 ---
        async function runTests() {
            setupMockData(); // 每次运行测试前重置数据
            console.log("[runTests] setupMockData complete. Starting a very simple battle test.");

            const simpleTeam = { id: 'simpleTeam', members: ['pf1'] };
            const simpleMonster = JSON.parse(JSON.stringify(monster1));
            
            try {
                console.log("[runTests] About to call battleInstance.startBattle with pf1.");
                // 确保 MockCharacter.characters 包含 pf1
                if (!MockCharacter.characters['pf1']) {
                    console.error("[runTests] CRITICAL: pf1 not in MockCharacter.characters before startBattle!");
                    MockCharacter.characters['pf1'] = JSON.parse(JSON.stringify(player_front1)); // 强制添加以防万一
                } else {
                    console.log("[runTests] pf1 IS in MockCharacter.characters before startBattle.");
                }

                battleInstance.startBattle(simpleTeam, simpleMonster, [MockCharacter.characters['pf1']]);
                
                if (battleInstance.currentBattle && battleInstance.currentBattle.teamMembers && battleInstance.currentBattle.teamMembers.length > 0) {
                    logResult("Simplified Battle Start Test", true, "Battle started and team members seem to be present.");
                } else {
                    logResult("Simplified Battle Start Test", false, "Battle did not start correctly or team members missing. battleInstance.currentBattle: " + JSON.stringify(battleInstance.currentBattle));
                }
            } catch (e) {
                logResult("Simplified Battle Start Test", false, "Error during battleInstance.startBattle: " + e.message + "\n" + e.stack);
            }

            // // 测试1: 验证核心流程顺序
            // await testPhaseOrder();

            // // 测试2: 验证我方技能阶段
            // await testPlayerSkillPhase();

            // // 测试3: 验证我方普攻阶段
            // await testPlayerAttackPhase();

            // // 测试4: 验证敌方行动阶段
            // await testEnemyPhase();

            // // 测试5: 验证状态处理 (Buff/Debuff, 回合效果)
            // await testStatusEffects();

            // // 测试6: 覆盖边缘情况
            // await testEdgeCases();

            // // 测试7: AoE 技能目标判定
            // await testAoESkillTargeting();

            // // 测试8: 后排替补逻辑
            // await testBacklineReinforcementLogic();

            // logResult("所有测试完成", true, "查看上方各个测试的详细结果。");
        }

        // --- 测试函数定义 ---

        async function testPhaseOrder() {
            setupMockData();
            const testName = "测试1: 验证核心流程顺序";
            let passed = true;
            let details = "";

            const originalLogBattle = battleInstance.logBattle;
            const phaseLogs = [];
            battleInstance.logBattle = (message) => {
                // originalLogBattle.call(battleInstance, message); // 可以在控制台也打印
                phaseLogs.push(message);
            };

            // 运行一回合战斗
            battleInstance.startBattle(team, JSON.parse(JSON.stringify(monster1))); // 使用怪物的深拷贝

            // 恢复原始 logBattle
            battleInstance.logBattle = originalLogBattle;

            const expectedOrder = [
                "--- 我方技能阶段 ---",
                "--- 我方普攻阶段 ---",
                "--- 敌方行动阶段 ---",
                "--- 回合结束处理 ---"
            ];

            let currentExpectedIndex = 0;
            for (const log of phaseLogs) {
                if (currentExpectedIndex < expectedOrder.length && log.includes(expectedOrder[currentExpectedIndex])) {
                    currentExpectedIndex++;
                }
            }

            if (currentExpectedIndex !== expectedOrder.length) {
                passed = false;
                details += `预期阶段顺序未完全匹配。\n预期: ${expectedOrder.join(' -> ')}\n实际日志包含的阶段标记: \n`;
                phaseLogs.forEach(log => {
                    if (log.startsWith("---") || log.startsWith("=====")) details += log + "\n";
                });
            } else {
                details = "战斗阶段顺序正确。";
            }

            logResult(testName, passed, details);
        }

        async function testPlayerSkillPhase() {
            setupMockData();
            const testName = "测试2: 验证我方技能阶段";
            let passed = true;
            let details = "";

            // 给 player1 一个CD为0的技能，player2一个需要CD的技能
            MockSkillLoader.skills['skill_p1_instant'] = { id: 'skill_p1_instant', name: '瞬发技', type: 'attack', targetType: 'enemy', effects: [{ type: 'damage', value: 10 }], cost: 0, cooldown: 0 };
            MockSkillLoader.skills['skill_p2_cd'] = { id: 'skill_p2_cd', name: '冷却技', type: 'buff', targetType: 'self', effects: [{ type: 'applyBuff', buffType: 'atk_up_s', duration: 1 }], cost: 0, cooldown: 1, initialCooldown: 1 }; // 初始CD 1
            player1.skills = ['skill_p1_instant'];
            player2.skills = ['skill_p2_cd'];
            player1.skillCooldowns = {}; player1.skillUsageCount = {};
            player2.skillCooldowns = {}; player2.skillUsageCount = {};


            const battleLog = [];
            const originalLog = battleInstance.logBattle;
            battleInstance.logBattle = (msg) => { battleLog.push(msg); /* originalLog.call(battleInstance, msg); */ };

            battleInstance.startBattle(team, JSON.parse(JSON.stringify(monster1))); // 仅运行一回合

            battleInstance.logBattle = originalLog;

            // 验证 player1 使用了瞬发技
            const p1UsedSkill = battleLog.some(log => log.includes(`${player1.name} 使用了技能 ${MockSkillLoader.skills['skill_p1_instant'].name}`));
            if (!p1UsedSkill) {
                passed = false;
                details += `${player1.name} 未按预期使用瞬发技能。\n`;
            }

            // 验证 player2 因为初始冷却未使用技能
            const p2UsedSkill = battleLog.some(log => log.includes(`${player2.name} 使用了技能 ${MockSkillLoader.skills['skill_p2_cd'].name}`));
            if (p2UsedSkill) {
                passed = false;
                details += `${player2.name} 不应在第一回合使用有初始冷却的技能，但日志显示使用了。\n`;
            }
            if (player2.skillCooldowns['skill_p2_cd'] === undefined || player2.skillCooldowns['skill_p2_cd'] === 0) {
                 // 技能如果没用，CD不应该被设置，或者如果被尝试使用但失败，CD也不应该进入0
                 // 这里要看 canUseSkill 和 setSkillCooldown 的具体逻辑
                 // 假设如果 canUseSkill 返回 false，则不会调用 setSkillCooldown
            }


            // 验证技能消耗和冷却 (对于 player1 的技能)
            if (p1UsedSkill && player1.skillCooldowns['skill_p1_instant'] !== 0) { // 瞬发技CD为0
                passed = false;
                details += `${player1.name} 的瞬发技能冷却设置不正确，应为0，实际为 ${player1.skillCooldowns['skill_p1_instant']}\n`;
            }

            // 模拟第二回合，player2的技能应该可用
            // setupMockData(); // 不要完全重置，保留 player1 和 player2 对象实例，但重置其状态和技能
            player1.skills = [];
            player1.currentStats = JSON.parse(JSON.stringify(player1.baseStats)); // 重置状态
            player1.buffs = []; player1.skillCooldowns = {}; player1.skillUsageCount = {}; player1.stats = { totalDamage: 0, totalHealing: 0, daCount: 0, taCount: 0, critCount: 0 };

            player2.skills = ['skill_p2_cd'];
            player2.currentStats = JSON.parse(JSON.stringify(player2.baseStats)); // 重置状态
            player2.buffs = []; player2.skillCooldowns = {}; player2.skillUsageCount = {}; player2.stats = { totalDamage: 0, totalHealing: 0, daCount: 0, taCount: 0, critCount: 0 };
            
            // 确保 skill_p2_cd 存在并修改其 initialCooldown
            if (!MockSkillLoader.skills['skill_p2_cd']) {
                MockSkillLoader.skills['skill_p2_cd'] = { id: 'skill_p2_cd', name: '冷却技', type: 'buff', targetType: 'self', effects: [{ type: 'applyBuff', buffType: 'atk_up_s', duration: 1 }], cost: 0, cooldown: 1, initialCooldown: 1 };
            }
            MockSkillLoader.skills['skill_p2_cd'].initialCooldown = 0;
            
            monster1.currentStats = JSON.parse(JSON.stringify(monster1.baseStats)); // 重置怪物状态
            monster1.currentStats.hp = 300;
            monster1.buffs = []; monster1.skillCooldowns = {}; monster1.skillUsageCount = {}; monster1.stats = { totalDamage: 0, totalHealing: 0 };


            // 确保 JobSkillsTemplate 也有这个技能
            if (!MockJobSkillsTemplate.templates['skill_p2_cd']) {
                MockJobSkillsTemplate.templates['skill_p2_cd'] = MockSkillLoader.skills['skill_p2_cd'];
            }

            const battleLogTurn2 = [];
            battleInstance.logBattle = (msg) => { battleLogTurn2.push(msg); };
            battleInstance.currentTurn = 0; // 手动重置回合计数器，模拟新战斗或特定回合
            battleInstance.isFirstTurn = true; // 确保初始冷却逻辑正确（如果适用）
            battleInstance.processBattle([player1, player2], monster1); // 直接调用 processBattle

            battleInstance.logBattle = originalLog;

            const p2UsedSkillTurn2 = battleLogTurn2.some(log => log.includes(`${player2.name} 使用了技能 ${MockSkillLoader.skills['skill_p2_cd'].name}`));
            if (!p2UsedSkillTurn2) {
                passed = false;
                details += `${player2.name} 在第二回合（模拟）未按预期使用冷却结束的技能。\n`;
            }
            if (p2UsedSkillTurn2 && player2.skillCooldowns['skill_p2_cd'] !== MockSkillLoader.skills['skill_p2_cd'].cooldown) {
                passed = false;
                details += `${player2.name} 的技能冷却设置不正确，预期 ${MockSkillLoader.skills['skill_p2_cd'].cooldown}，实际 ${player2.skillCooldowns['skill_p2_cd']}\n`;
            }


            if (passed) details = "我方技能阶段基本逻辑正确。";
            logResult(testName, passed, details + "\n战斗日志:\n" + battleLog.join("\n") + "\n模拟第二回合日志:\n" + battleLogTurn2.join("\n"));
        }

        async function testPlayerAttackPhase() {
            setupMockData();
            const testName = "测试3: 验证我方普攻阶段";
            let passed = true;
            let details = "";

            // 确保角色在技能阶段后能普攻
            player1.skills = []; // 无技能
            player2.skills = []; // 无技能

            const battleLog = [];
            const originalLog = battleInstance.logBattle;
            battleInstance.logBattle = (msg) => { battleLog.push(msg); /* originalLog.call(battleInstance, msg); */};

            battleInstance.startBattle(team, JSON.parse(JSON.stringify(monster1)));

            battleInstance.logBattle = originalLog;

            const p1Attacked = battleLog.some(log => log.includes(`${player1.name}`) && (log.includes("普通攻击") || log.includes("双重攻击") || log.includes("三重攻击")) && log.includes(`对 ${monster1.name} 造成`));
            const p2Attacked = battleLog.some(log => log.includes(`${player2.name}`) && (log.includes("普通攻击") || log.includes("双重攻击") || log.includes("三重攻击")) && log.includes(`对 ${monster1.name} 造成`));

            if (!p1Attacked) {
                passed = false;
                details += `${player1.name} 未执行普通攻击。\n`;
            }
            if (!p2Attacked) {
                passed = false;
                details += `${player2.name} 未执行普通攻击。\n`;
            }

            // 验证伤害是否记录
            if (p1Attacked && player1.stats.totalDamage <= 0) {
                passed = false;
                details += `${player1.name} 执行了普攻但伤害未记录到 stats.totalDamage。\n`;
            }
             if (p2Attacked && player2.stats.totalDamage <= 0) {
                passed = false;
                details += `${player2.name} 执行了普攻但伤害未记录到 stats.totalDamage。\n`;
            }
            // 验证怪物受到伤害
            const monsterHpBefore = 300;
            if ((p1Attacked || p2Attacked) && monster1.currentStats.hp >= monsterHpBefore) {
                 // 注意：monster1 在 battleInstance.startBattle 中是深拷贝的，所以这里的 monster1 是原始的。
                 // 我们需要从 battleInstance.currentBattle.monster 获取战斗后的怪物状态
                const battleResultMonster = battleInstance.currentBattle ? battleInstance.currentBattle.monster : null;
                if (battleResultMonster && battleResultMonster.currentStats.hp >= monsterHpBefore) {
                    passed = false;
                    details += `怪物 ${monster1.name} 在受到攻击后HP未减少。HP: ${battleResultMonster.currentStats.hp}\n`;
                } else if (!battleResultMonster) {
                    passed = false;
                    details += `无法获取战斗后的怪物状态来验证HP减少。\n`;
                }
            }


            if (passed) details = "我方普攻阶段基本逻辑正确。";
            logResult(testName, passed, details + "\n战斗日志:\n" + battleLog.join("\n"));
        }

        async function testEnemyPhase() {
            setupMockData();
            const testName = "测试4: 验证敌方行动阶段";
            let passed = true;
            let details = "";

            // 确保怪物能行动
            const battleLog = [];
            const originalLog = battleInstance.logBattle;
            battleInstance.logBattle = (msg) => { battleLog.push(msg); /* originalLog.call(battleInstance, msg); */ };

            battleInstance.startBattle(team, JSON.parse(JSON.stringify(monster1)));

            battleInstance.logBattle = originalLog;

            const enemyActed = battleLog.some(log => log.includes(`${monster1.name}`) && (log.includes("普通攻击") || log.includes("使用了技能")));
            if (!enemyActed) {
                passed = false;
                details += `${monster1.name} 未执行任何行动。\n`;
            }

            // 验证怪物攻击是否对玩家造成伤害
            const player1HpBefore = player1.currentStats.hp;
            const player2HpBefore = player2.currentStats.hp;

            const battleResultTeam = battleInstance.currentBattle ? battleInstance.currentBattle.teamMembers : null;
            if (enemyActed && battleResultTeam) {
                const p1After = battleResultTeam.find(p => p.id === player1.id);
                const p2After = battleResultTeam.find(p => p.id === player2.id);
                let playerDamaged = false;
                if (p1After && p1After.currentStats.hp < player1HpBefore) playerDamaged = true;
                if (p2After && p2After.currentStats.hp < player2HpBefore) playerDamaged = true;

                if (!playerDamaged && battleLog.some(log => log.includes(`${monster1.name} 对`) && log.includes("造成"))) {
                    // 怪物日志显示造成伤害，但玩家血量没变
                     passed = false;
                     details += `${monster1.name} 行动日志显示造成伤害，但玩家HP未减少。\n`;
                     details += `P1 HP: ${player1HpBefore} -> ${p1After ? p1After.currentStats.hp : 'N/A'}\n`;
                     details += `P2 HP: ${player2HpBefore} -> ${p2After ? p2After.currentStats.hp : 'N/A'}\n`;
                }
            } else if (enemyActed && !battleResultTeam) {
                passed = false;
                details += `无法获取战斗后的队伍状态来验证玩家HP减少。\n`;
            }


            if (passed) details = "敌方行动阶段基本逻辑正确。";
            logResult(testName, passed, details + "\n战斗日志:\n" + battleLog.join("\n"));
        }

        async function testStatusEffects() {
            setupMockData();
            const testName = "测试5: 验证状态处理";
            let passed = true;
            let details = "";
            const battleLog = [];
            const originalLog = battleInstance.logBattle;
            battleInstance.logBattle = (msg) => { battleLog.push(msg); /* originalLog.call(battleInstance, msg); */ };

            // 5.1 Buff/Debuff 施加、持续时间、移除
            MockSkillLoader.skills['skill_apply_buff_p1'] = { id: 'skill_apply_buff_p1', name: '施加增益', type: 'buff', targetType: 'self', effects: [{ type: 'applyBuff', buffType: 'atk_up_s', duration: 2 }], cost: 0, cooldown: 0 };
            MockSkillLoader.skills['skill_apply_debuff_m1'] = { id: 'skill_apply_debuff_m1', name: '施加减益', type: 'debuff', targetType: 'enemy', effects: [{ type: 'applyBuff', buffType: 'def_down_s', duration: 1 }], cost: 0, cooldown: 0 }; // 持续1回合，方便测试移除
            player1.skills = ['skill_apply_buff_p1'];
            monster1.skills = ['skill_apply_debuff_m1']; // 怪物使用减益技能
            player1.buffs = []; monster1.buffs = []; // 清空buff

            battleInstance.startBattle(team, JSON.parse(JSON.stringify(monster1))); // 第1回合

            const p1HasAtkUp = player1.buffs.some(b => b.id === 'atk_up_s' && b.currentDuration === 1); // 使用后消耗1回合
            if (!p1HasAtkUp) {
                passed = false;
                details += "Player1 未能成功施加 atk_up_s 或持续时间不正确 (应为1)。Buffs: " + JSON.stringify(player1.buffs.map(b=>({id:b.id, dur:b.currentDuration}))) + "\n";
            }

            const monsterHasDefDown = monster1.buffs.some(b => b.id === 'def_down_s' && b.currentDuration === 0); // 怪物行动后，它的buff也应该消耗1回合
            // 注意：这里的 monster1 是 startBattle 内部的拷贝，我们需要从 battleInstance.currentBattle.monster 获取
            const battleMonster = battleInstance.currentBattle.monster;
            const monsterHasDefDownAfterBattle = battleMonster.buffs.some(b => b.id === 'def_down_s' && b.currentDuration === 0);


            if (!monsterHasDefDownAfterBattle) {
                passed = false;
                details += "Monster1 未能成功被施加 def_down_s 或其持续时间不正确 (应为0)。Buffs: " + JSON.stringify(battleMonster.buffs.map(b=>({id:b.id, dur:b.currentDuration}))) + "\n";
            }

            // 模拟进入下一回合，检查buff是否移除
            // 需要手动调用回合结束和开始的buff处理逻辑，或者完整模拟一回合
            // 为了简化，我们直接检查 battle.js 的 updateBuffDurations
            // 假设战斗继续，再过一回合
            if (p1HasAtkUp) { // 如果P1有buff
                battleInstance.updateBuffDurations([player1], battleMonster); // 手动更新P1的buff
                const p1AtkUpRemoved = !player1.buffs.some(b => b.id === 'atk_up_s');
                if (!p1AtkUpRemoved) {
                    passed = false;
                    details += "Player1 的 atk_up_s 在预期持续时间结束后未被移除。Buffs: " + JSON.stringify(player1.buffs.map(b=>({id:b.id, dur:b.currentDuration}))) + "\n";
                }
            }

            if (monsterHasDefDownAfterBattle) { // 如果怪物有buff
                 battleInstance.updateBuffDurations([], battleMonster); // 手动更新怪物的buff
                 const monsterDefDownRemoved = !battleMonster.buffs.some(b => b.id === 'def_down_s');
                 if (!monsterDefDownRemoved) {
                    passed = false;
                    details += "Monster1 的 def_down_s 在预期持续时间结束后未被移除。Buffs: " + JSON.stringify(battleMonster.buffs.map(b=>({id:b.id, dur:b.currentDuration}))) + "\n";
                 }
            }


            // 5.2 回合开始/结束效果 (例如中毒、再生)
            setupMockData(); // 重置
            MockSkillLoader.skills['skill_apply_poison'] = { id: 'skill_apply_poison', name: '施加中毒', type: 'debuff', targetType: 'enemy', effects: [{ type: 'applyBuff', buffType: 'poison', duration: 2 }], cost: 0, cooldown: 0 };
            player1.skills = ['skill_apply_poison'];
            monster1.skills = []; // 怪物不行动，方便观察
            monster1.currentStats.hp = 100; // 设置一个固定血量
            const monsterHpBeforePoison = monster1.currentStats.hp;

            battleInstance.startBattle(team, JSON.parse(JSON.stringify(monster1))); // 第1回合，P1给怪物上毒

            const battleMonsterAfterPoison = battleInstance.currentBattle.monster;
            const monsterIsPoisoned = battleMonsterAfterPoison.buffs.some(b => b.id === 'poison');
            if (!monsterIsPoisoned) {
                passed = false;
                details += "怪物未能成功中毒。\n";
            }

            // 检查回合结束时中毒是否造成伤害 (processTurnStartBuffs 在新流程中处理DOT)
            // battle.js 的 processBattle -> processTurnStartBuffs (在下一回合开始时) -> BuffSystem.processBuffsAtTurnStart
            // 所以毒伤应该在第二回合开始时结算
            // 我们需要模拟到第二回合开始
            let monsterHpAfterPoisonTick = battleMonsterAfterPoison.currentStats.hp;
            if (monsterIsPoisoned) {
                // 模拟回合结束和下一回合开始的buff处理
                battleInstance.processTurnStartBuffs([], battleMonsterAfterPoison); // 手动调用下一回合开始的buff处理
                monsterHpAfterPoisonTick = battleMonsterAfterPoison.currentStats.hp;
                const poisonDamage = MockBuffSystem.buffsData['poison'].damage;
                if (monsterHpAfterPoisonTick >= monsterHpBeforePoison) { // 如果是严格等于，说明没掉血
                    passed = false;
                    details += `中毒效果在回合开始时未对怪物造成伤害。HP: ${monsterHpBeforePoison} -> ${monsterHpAfterPoisonTick}。预期伤害: ${poisonDamage}\n`;
                } else if (monsterHpBeforePoison - monsterHpAfterPoisonTick !== poisonDamage) {
                    passed = false;
                    details += `中毒伤害不符合预期。实际伤害: ${monsterHpBeforePoison - monsterHpAfterPoisonTick}，预期伤害: ${poisonDamage}\n`;
                }
            }

            // 测试再生 (回合结束效果，由 processEndOfTurnEffect -> handleProcTrigger -> onTurnEnd)
            setupMockData();
            player1.skills = ['skill_passive_regen']; // 被动再生技能
            player1.currentStats.hp = 50; // 设置一个较低的血量
            const playerHpBeforeRegen = player1.currentStats.hp;
            monster1.skills = [];

            battleInstance.startBattle(team, JSON.parse(JSON.stringify(monster1))); // 运行一回合

            const playerHpAfterRegen = player1.currentStats.hp; // player1 是引用，会被修改
            const regenAmount = MockSkillLoader.skills['skill_passive_regen'].effects[0].triggeredEffects[0].value;

            if (playerHpAfterRegen <= playerHpBeforeRegen) {
                passed = false;
                details += `再生效果在回合结束时未恢复HP。HP: ${playerHpBeforeRegen} -> ${playerHpAfterRegen}。预期治疗: ${regenAmount}\n`;
            } else if (playerHpAfterRegen - playerHpBeforeRegen !== regenAmount && playerHpBeforeRegen + regenAmount <= player1.currentStats.maxHp) {
                // 只有在没达到满血的情况下，治疗量才应该精确匹配
                passed = false;
                details += `再生治疗量不符合预期。实际治疗: ${playerHpAfterRegen - playerHpBeforeRegen}，预期治疗: ${regenAmount}\n`;
            }


            battleInstance.logBattle = originalLog;
            if (passed) details = "状态处理基本逻辑正确。";
            logResult(testName, passed, details + "\n战斗日志:\n" + battleLog.join("\n"));
        }

        async function testEdgeCases() {
            setupMockData();
            const testName = "测试6: 覆盖边缘情况";
            let passed = true;
            let details = "";
            const battleLog = [];
            const originalLog = battleInstance.logBattle;
            battleInstance.logBattle = (msg) => { battleLog.push(msg); /* originalLog.call(battleInstance, msg); */ };

            // 6.1 角色在回合中死亡
            player1.currentStats.hp = 10; // P1血量很低
            monster1.currentStats.attack = 100; // 怪物高攻，确保能秒杀P1
            monster1.skills = ['skill_attack_single']; // 怪物用单体攻击
            MockSkillLoader.skills['skill_attack_single'].effects = [{ type: 'damage', value: 100 }]; // 确保技能伤害足够

            battleInstance.startBattle(JSON.parse(JSON.stringify(team)), JSON.parse(JSON.stringify(monster1)));

            const p1Dead = player1.currentStats.hp <= 0;
            if (!p1Dead) {
                passed = false;
                details += "角色在回合中受到致命伤害后未死亡。\n";
            }
            // 检查死亡角色是否不再行动 (例如，P1死亡后，P2是否还行动)
            // 这个比较复杂，因为P1可能在怪物行动前就死了，也可能在怪物行动后。
            // 如果P1在怪物行动阶段死亡，那么P1本回合的技能和普攻阶段应该已经执行过了。
            // 我们主要关注战斗是否能正确处理死亡状态。
            const p1ActedAfterNearDeath = battleLog.some(log => log.includes("勇者 使用了技能") || log.includes("勇者 普通攻击")) && p1Dead;
            // 这个判断不完美，因为日志顺序问题。更可靠的是检查战斗结果。

            // 6.2 没有可用技能的角色 (应该只普攻)
            setupMockData();
            player1.skills = []; // P1无技能
            player2.skills = ['skill_high_cooldown']; // P2技能在CD中
            player2.skillCooldowns['skill_high_cooldown'] = MockSkillLoader.skills['skill_high_cooldown'].initialCooldown; // 确保在CD

            battleLog.length = 0; // 清空日志
            battleInstance.startBattle(team, JSON.parse(JSON.stringify(monster1)));

            const p1UsedSkillNoSkill = battleLog.some(log => log.includes(`${player1.name} 使用了技能`));
            const p2UsedSkillOnCD = battleLog.some(log => log.includes(`${player2.name} 使用了技能 ${MockSkillLoader.skills['skill_high_cooldown'].name}`));

            if (p1UsedSkillNoSkill) {
                passed = false;
                details += `${player1.name} 没有技能但不应尝试使用技能。\n`;
            }
            if (p2UsedSkillOnCD) {
                passed = false;
                details += `${player2.name} 技能在冷却中但不应尝试使用技能。\n`;
            }
            const p1AttackedNoSkill = battleLog.some(log => log.includes(`${player1.name}`) && (log.includes("普通攻击") || log.includes("双重攻击") || log.includes("三重攻击")));
            const p2AttackedSkillOnCD = battleLog.some(log => log.includes(`${player2.name}`) && (log.includes("普通攻击") || log.includes("双重攻击") || log.includes("三重攻击")));
            if (!p1AttackedNoSkill) {
                passed = false;
                details += `${player1.name} 没有技能时未执行普攻。\n`;
            }
            if (!p2AttackedSkillOnCD) {
                passed = false;
                details += `${player2.name} 技能冷却时未执行普攻。\n`;
            }

            // 6.3 技能效果（如眩晕、沉默）对后续行动的影响
            setupMockData();
            // P1给怪物上眩晕
            player1.skills = ['skill_stun_enemy'];
            player1.currentStats.mp = 100; // 确保蓝够
            MockSkillLoader.skills['skill_stun_enemy'].cost = 10;
            MockSkillLoader.skills['skill_stun_enemy'].cooldown = 0;
            monster1.skills = ['skill_attack_single']; // 怪物有个攻击技能
            monster1.currentStats.hp = 500; // 确保怪物第一回合不死

            battleLog.length = 0;
            battleInstance.startBattle(team, JSON.parse(JSON.stringify(monster1))); // P1行动，给怪物上眩晕

            const battleMonsterStunned = battleInstance.currentBattle.monster;
            const monsterIsStunned = battleMonsterStunned.buffs.some(b => b.id === 'stun');
            if (!monsterIsStunned) {
                passed = false;
                details += "怪物未能成功被眩晕。\n";
            }

            const monsterActedWhileStunned = battleLog.some(log => log.includes(`${monster1.name} 使用了技能`) || log.includes(`${monster1.name} 普通攻击`));
            if (monsterIsStunned && monsterActedWhileStunned) {
                passed = false;
                details += "怪物在眩晕状态下依然行动了。\n";
            }

            // 测试沉默
            setupMockData();
            player1.skills = ['skill_silence_enemy']; // P1给怪物上沉默
            player1.currentStats.mp = 100;
            MockSkillLoader.skills['skill_silence_enemy'].cost = 10;
            MockSkillLoader.skills['skill_silence_enemy'].cooldown = 0;
            monster1.skills = ['skill_attack_single']; // 怪物有个技能
            monster1.currentStats.hp = 500;

            battleLog.length = 0;
            battleInstance.startBattle(team, JSON.parse(JSON.stringify(monster1)));

            const battleMonsterSilenced = battleInstance.currentBattle.monster;
            const monsterIsSilenced = battleMonsterSilenced.buffs.some(b => b.id === 'silence');
            if (!monsterIsSilenced) {
                passed = false;
                details += "怪物未能成功被沉默。\n";
            }
            const monsterUsedSkillWhileSilenced = battleLog.some(log => log.includes(`${monster1.name} 使用了技能`));
            const monsterAttackedWhileSilenced = battleLog.some(log => log.includes(`${monster1.name} 普通攻击`));
            if (monsterIsSilenced && monsterUsedSkillWhileSilenced) {
                passed = false;
                details += "怪物在沉默状态下依然使用了技能。\n";
            }
            if (monsterIsSilenced && !monsterAttackedWhileSilenced) {
                // 沉默通常不阻止普攻，除非特殊设计
                // details += "怪物在沉默状态下没有执行普攻 (如果设计是沉默也阻止普攻，则此条忽略)。\n";
            }


            // 6.4 战斗提前结束（某一方全部阵亡）
            setupMockData();
            player1.currentStats.hp = 1; player2.currentStats.hp = 1; // 玩家血少
            monster1.currentStats.attack = 10; // 怪物攻击力不高但能打死
            monster1.skills = ['skill_attack_single'];
            MockSkillLoader.skills['skill_attack_single'].effects = [{ type: 'damage', value: 10 }];

            battleLog.length = 0;
            const resultTeamWipe = battleInstance.startBattle(team, JSON.parse(JSON.stringify(monster1)));
            if (resultTeamWipe.victory) {
                passed = false;
                details += "玩家方全部阵亡，但战斗结果判定为胜利。\n";
            }
            if (battleInstance.currentTurn >= battleInstance.MAX_TURNS) { // MAX_TURNS 默认是 99
                // passed = false; // 这个不一定，可能确实打了很多回合
                // details += "战斗在一方全灭后未及时结束，可能达到了最大回合数。\n";
            }
            const teamAliveAfterWipe = resultTeamWipe.teamMembers.some(m => m.currentStats.hp > 0);
            if (teamAliveAfterWipe) {
                passed = false;
                details += "玩家方应全部阵亡，但仍有角色存活。\n";
            }

            setupMockData();
            monster1.currentStats.hp = 1; // 怪物血少
            player1.currentStats.attack = 10;
            player1.skills = ['skill_no_cost_quick']; // P1有个快速攻击技能

            battleLog.length = 0;
            const resultMonsterWipe = battleInstance.startBattle(team, JSON.parse(JSON.stringify(monster1)));
            if (!resultMonsterWipe.victory) {
                passed = false;
                details += "怪物方全部阵亡，但战斗结果判定为失败。\n";
            }
            if (resultMonsterWipe.monster.currentStats.hp > 0) {
                passed = false;
                details += "怪物方应全部阵亡，但怪物仍存活。\n";
            }


            battleInstance.logBattle = originalLog;
            if (passed) details = "边缘情况处理基本逻辑正确。";
            logResult(testName, passed, details + "\n部分战斗日志:\n" + battleLog.slice(-50).join("\n")); // 只显示最后一些日志
        }

        async function testAoESkillTargeting() {
            setupMockData(); // 使用通用的设置，但可能需要为特定场景调整
            const testName = "测试7: AoE 及单体技能目标判定";
            let passed = true;
            let details = "";
            const battleLog = [];
            const originalLogBattle = battleInstance.logBattle;
            battleInstance.logBattle = (msg) => { battleLog.push(msg); /* originalLogBattle.call(battleInstance, msg); */ };

            // --- 子测试场景 ---

            // 场景1: 怪物使用 all_enemies AoE 技能 (攻击我方全体)
            details += "\n--- 场景1: 怪物使用 all_enemies AoE ---\n";
            setupMockData(); // 重置数据
            const currentMonster = JSON.parse(JSON.stringify(monster_aoe_user)); // 使用会AoE的怪物
            const currentTeam = teamOfThree.members.map(id => JSON.parse(JSON.stringify(MockCharacter.characters[id])));
            
            // 模拟战斗，让怪物行动
            // Battle.processMonsterAction(monster, teamMembers, battleStats)
            // 我们需要模拟 Battle.js 调用 JobSkills.useSkill 的方式
            // Battle.js 内部会选择技能和目标，然后调用 JobSkills.useSkill(caster, skillId, teamMembers, monster, isCasterPlayer)
            // 这里我们直接调用 MockJobSkills.useSkill 来模拟怪物使用技能
            
            const skillToUseByMonster = 'skill_monster_aoe_player';
            MockJobSkills.useSkill(currentMonster, skillToUseByMonster, currentTeam, currentMonster, false); // isCasterPlayer = false

            if (!MockJobSkills.lastCallArgs) {
                passed = false;
                details += "MockJobSkills.useSkill 未被调用。\n";
            } else {
                const determinedTargets = MockJobSkills.lastCallArgs.determinedTargets;
                if (!determinedTargets || determinedTargets.length !== 3) {
                    passed = false;
                    details += `怪物 AoE 技能目标数量不正确。预期: 3, 实际: ${determinedTargets ? determinedTargets.length : 0}\n`;
                } else {
                    const targetIds = determinedTargets.map(t => t.id).sort();
                    const expectedTargetIds = ['player1', 'player2', 'player3'].sort();
                    if (JSON.stringify(targetIds) !== JSON.stringify(expectedTargetIds)) {
                        passed = false;
                        details += `怪物 AoE 技能目标不正确。预期: ${expectedTargetIds.join(',')}, 实际: ${targetIds.join(',')}\n`;
                    } else {
                        details += "怪物 AoE (all_enemies) 目标判定正确。\n";
                    }
                }
                // 验证血量变化 (可选，因为我们主要测试目标选择)
                currentTeam.forEach(p => {
                    const originalPlayer = MockCharacter.characters[p.id];
                    if (p.currentStats.hp >= originalPlayer.currentStats.hp) {
                         // passed = false; // 暂时不严格检查这个，因为模拟的伤害可能为0或有其他因素
                         details += `警告: 玩家 ${p.name} 在怪物AoE后HP未减少 (HP: ${p.currentStats.hp})。\n`;
                    }
                });
            }
            MockJobSkills.lastCallArgs = null; // 重置记录


            // 场景2: 玩家使用 all_enemies AoE 技能 (目标为单个怪物)
            details += "\n--- 场景2: 玩家使用 all_enemies AoE ---\n";
            setupMockData();
            const p1 = JSON.parse(JSON.stringify(player1));
            const m1 = JSON.parse(JSON.stringify(monster1));
            const p1Team = [p1, JSON.parse(JSON.stringify(player2))]; // 玩家队伍
            const skillPlayerAoE = 'skill_player_aoe_enemies';

            MockJobSkills.useSkill(p1, skillPlayerAoE, p1Team, m1, true); // isCasterPlayer = true

            if (!MockJobSkills.lastCallArgs) {
                passed = false;
                details += "场景2: MockJobSkills.useSkill 未被调用。\n";
            } else {
                const determinedTargets = MockJobSkills.lastCallArgs.determinedTargets;
                if (!determinedTargets || determinedTargets.length !== 1 || determinedTargets[0].id !== m1.id) {
                    passed = false;
                    details += `场景2: 玩家 AoE (all_enemies) 目标不正确。预期: [${m1.id}], 实际: ${determinedTargets ? determinedTargets.map(t=>t.id).join(',') : '无'}\n`;
                } else {
                    details += "场景2: 玩家 AoE (all_enemies) 目标判定正确。\n";
                }
            }
            MockJobSkills.lastCallArgs = null;

            // 场景3: 玩家使用 all_allies AoE 技能
            details += "\n--- 场景3: 玩家使用 all_allies AoE ---\n";
            setupMockData();
            const p1ForAllyAoe = JSON.parse(JSON.stringify(player1));
            const p2ForAllyAoe = JSON.parse(JSON.stringify(player2));
            const p3ForAllyAoe = JSON.parse(JSON.stringify(player3));
            p3ForAllyAoe.currentStats.hp = 10; // 让一个队友掉血，方便测试治疗效果
            const teamForAllyAoe = [p1ForAllyAoe, p2ForAllyAoe, p3ForAllyAoe];
            const m1ForAllyAoe = JSON.parse(JSON.stringify(monster1));
            const skillPlayerAoeAllies = 'skill_player_aoe_allies';

            MockJobSkills.useSkill(p1ForAllyAoe, skillPlayerAoeAllies, teamForAllyAoe, m1ForAllyAoe, true);

            if (!MockJobSkills.lastCallArgs) {
                passed = false;
                details += "场景3: MockJobSkills.useSkill 未被调用。\n";
            } else {
                const determinedTargets = MockJobSkills.lastCallArgs.determinedTargets;
                const expectedTargetIds = teamForAllyAoe.map(p => p.id).sort();
                if (!determinedTargets || determinedTargets.length !== 3) {
                    passed = false;
                    details += `场景3: 玩家 AoE (all_allies) 目标数量不正确。预期: 3, 实际: ${determinedTargets ? determinedTargets.length : 0}\n`;
                } else {
                    const targetIds = determinedTargets.map(t => t.id).sort();
                    if (JSON.stringify(targetIds) !== JSON.stringify(expectedTargetIds)) {
                        passed = false;
                        details += `场景3: 玩家 AoE (all_allies) 目标不正确。预期: ${expectedTargetIds.join(',')}, 实际: ${targetIds.join(',')}\n`;
                    } else {
                        details += "场景3: 玩家 AoE (all_allies) 目标判定正确。\n";
                    }
                }
            }
            MockJobSkills.lastCallArgs = null;
            
            // 场景4: 怪物使用 single_enemy 技能
            details += "\n--- 场景4: 怪物使用 single_enemy ---\n";
            setupMockData();
            const monsterForSingle = JSON.parse(JSON.stringify(monster1)); // 普通哥布林
            const teamForMonsterSingle = teamOfThree.members.map(id => JSON.parse(JSON.stringify(MockCharacter.characters[id])));
            const skillMonsterSingle = 'skill_attack_single'; // 怪物用单体攻击
            monsterForSingle.skills = [skillMonsterSingle];


            MockJobSkills.useSkill(monsterForSingle, skillMonsterSingle, teamForMonsterSingle, monsterForSingle, false);

            if (!MockJobSkills.lastCallArgs) {
                passed = false;
                details += "场景4: MockJobSkills.useSkill 未被调用。\n";
            } else {
                const determinedTargets = MockJobSkills.lastCallArgs.determinedTargets;
                 // 模拟中，怪物单体攻击默认打第一个玩家
                if (!determinedTargets || determinedTargets.length !== 1 || determinedTargets[0].id !== teamForMonsterSingle[0].id) {
                    passed = false;
                    details += `场景4: 怪物 single_enemy 目标不正确。预期: [${teamForMonsterSingle[0].id}], 实际: ${determinedTargets ? determinedTargets.map(t=>t.id).join(',') : '无'}\n`;
                } else {
                    details += "场景4: 怪物 single_enemy 目标判定正确 (模拟选择第一个玩家)。\n";
                }
            }
            MockJobSkills.lastCallArgs = null;

            // 场景5: 玩家使用 single_enemy 技能
            details += "\n--- 场景5: 玩家使用 single_enemy ---\n";
            setupMockData();
            const p1ForSingleEnemy = JSON.parse(JSON.stringify(player1));
            const m1ForPlayerSingle = JSON.parse(JSON.stringify(monster1));
            const p1TeamForSingle = [p1ForSingleEnemy];
            const skillPlayerSingleEnemy = 'skill_attack_single';

            MockJobSkills.useSkill(p1ForSingleEnemy, skillPlayerSingleEnemy, p1TeamForSingle, m1ForPlayerSingle, true);
            if (!MockJobSkills.lastCallArgs) {
                passed = false;
                details += "场景5: MockJobSkills.useSkill 未被调用。\n";
            } else {
                const determinedTargets = MockJobSkills.lastCallArgs.determinedTargets;
                if (!determinedTargets || determinedTargets.length !== 1 || determinedTargets[0].id !== m1ForPlayerSingle.id) {
                    passed = false;
                    details += `场景5: 玩家 single_enemy 目标不正确。预期: [${m1ForPlayerSingle.id}], 实际: ${determinedTargets ? determinedTargets.map(t=>t.id).join(',') : '无'}\n`;
                } else {
                    details += "场景5: 玩家 single_enemy 目标判定正确。\n";
                }
            }
            MockJobSkills.lastCallArgs = null;

            // 场景6: 怪物使用 single_ally 技能 (通常是自身)
            details += "\n--- 场景6: 怪物使用 single_ally ---\n";
            setupMockData();
            const monsterForSelfBuff = JSON.parse(JSON.stringify(monster_aoe_user)); // 用史莱姆王，它有个单体友方buff
            const teamForMonsterSelfBuff = teamOfThree.members.map(id => JSON.parse(JSON.stringify(MockCharacter.characters[id])));
            const skillMonsterSelfBuff = 'skill_monster_single_ally_buff';

            MockJobSkills.useSkill(monsterForSelfBuff, skillMonsterSelfBuff, teamForMonsterSelfBuff, monsterForSelfBuff, false);

            if (!MockJobSkills.lastCallArgs) {
                passed = false;
                details += "场景6: MockJobSkills.useSkill 未被调用。\n";
            } else {
                const determinedTargets = MockJobSkills.lastCallArgs.determinedTargets;
                if (!determinedTargets || determinedTargets.length !== 1 || determinedTargets[0].id !== monsterForSelfBuff.id) {
                    passed = false;
                    details += `场景6: 怪物 single_ally 目标不正确。预期: [${monsterForSelfBuff.id}], 实际: ${determinedTargets ? determinedTargets.map(t=>t.id).join(',') : '无'}\n`;
                } else {
                    details += "场景6: 怪物 single_ally 目标判定正确 (目标为自身)。\n";
                }
            }
            MockJobSkills.lastCallArgs = null;

            // 场景7: 玩家使用 single_ally 技能
            details += "\n--- 场景7: 玩家使用 single_ally ---\n";
            setupMockData();
            const p1ForSingleAlly = JSON.parse(JSON.stringify(player1));
            const p2ForSingleAlly = JSON.parse(JSON.stringify(player2));
            p2ForSingleAlly.currentStats.hp = 50; // 让P2掉血，方便测试治疗
            const teamForPlayerSingleAlly = [p1ForSingleAlly, p2ForSingleAlly];
            const m1ForPlayerSingleAlly = JSON.parse(JSON.stringify(monster1));
            const skillPlayerSingleAlly = 'skill_heal_single'; // 治疗技能，目标类型 ally_lowest_hp (在模拟中简化为第一个队友)

            MockJobSkills.useSkill(p1ForSingleAlly, skillPlayerSingleAlly, teamForPlayerSingleAlly, m1ForPlayerSingleAlly, true);
            if (!MockJobSkills.lastCallArgs) {
                passed = false;
                details += "场景7: MockJobSkills.useSkill 未被调用。\n";
            } else {
                const determinedTargets = MockJobSkills.lastCallArgs.determinedTargets;
                // 模拟中，玩家单体友方技能默认选择第一个队友 (或最低血量，这里简化)
                // 我们的 MockJobSkills.useSkill 简化为选择第一个队友
                const expectedTargetId = teamForPlayerSingleAlly[0].id; // MockJobSkills 简化逻辑
                if (!determinedTargets || determinedTargets.length !== 1 || determinedTargets[0].id !== expectedTargetId) {
                    passed = false;
                    details += `场景7: 玩家 single_ally 目标不正确。预期: [${expectedTargetId}], 实际: ${determinedTargets ? determinedTargets.map(t=>t.id).join(',') : '无'}\n`;
                } else {
                    details += "场景7: 玩家 single_ally 目标判定正确 (模拟选择第一个队友)。\n";
                }
            }
            MockJobSkills.lastCallArgs = null;


            if (passed) details = "AoE 及单体技能目标判定测试初步通过。\n" + details;
            else details = "AoE 及单体技能目标判定测试失败。\n" + details;
            
            logResult(testName, passed, details + "\n战斗日志:\n" + battleLog.join("\n"));
            battleInstance.logBattle = originalLogBattle;
        }

        async function testBacklineReinforcementLogic() {
            const testName = "测试8: 后排替补逻辑";
            let allSubtestsPassed = true;
            let subtestDetails = "";

            function logSubResult(name, passed, detail) {
                subtestDetails += `\n--- ${name} ---\n${detail}\nResult: ${passed ? 'PASS' : 'FAIL'}\n`;
                if (!passed) allSubtestsPassed = false;
                console.log(`${testName} - ${name}: ${passed ? 'PASS' : 'FAIL'}`, detail);
            }

            // 子测试 8.1: 后排单位HP在战斗开始时被设置为最大HP
            setupMockData();
            let backlineTeamMembers = teamWithBackline.members.map(id => JSON.parse(JSON.stringify(MockCharacter.characters[id])));
            // 确保 pb1 (后援甲) 初始HP不满
            const pb1_initial = backlineTeamMembers.find(m => m.id === 'pb1');
            if (pb1_initial) pb1_initial.currentStats.hp = 50; // 明确设置不满

            // 传递角色实例数组作为第三个参数
            console.log("[testBacklineReinforcementLogic] 调用 battleInstance.startBattle (8.1) 前，backlineTeamMembers:", JSON.parse(JSON.stringify(backlineTeamMembers.map(m=>({id:m.id, hp:m.currentStats.hp})))));
            battleInstance.startBattle(teamWithBackline, JSON.parse(JSON.stringify(monster1)), backlineTeamMembers);
            
            if (!battleInstance.currentBattle) {
                logSubResult("8.1 后排HP恢复", false, "battleInstance.currentBattle 为 null，无法继续测试。");
                logResult(testName, false, subtestDetails); // 提前结束测试8
                return; // 退出 testBacklineReinforcementLogic
            }
            if (!battleInstance.currentBattle.teamMembers) {
                logSubResult("8.1 后排HP恢复", false, "battleInstance.currentBattle.teamMembers 为 null，无法继续测试。");
                logResult(testName, false, subtestDetails); // 提前结束测试8
                return; // 退出 testBacklineReinforcementLogic
            }

            const pb1_after_start = battleInstance.currentBattle.teamMembers.find(m => m.id === 'pb1');
            let passed_8_1 = false;
            let detail_8_1 = "";
            if (pb1_after_start && pb1_after_start.position === 'back') {
                if (pb1_after_start.currentStats.hp === pb1_after_start.currentStats.maxHp) {
                    passed_8_1 = true;
                    detail_8_1 = `后援甲 (pb1) 在战斗开始时HP已恢复至最大 (${pb1_after_start.currentStats.hp}/${pb1_after_start.currentStats.maxHp})。`;
                } else {
                    detail_8_1 = `后援甲 (pb1) 在战斗开始时HP未恢复至最大。预期: ${pb1_after_start.currentStats.maxHp}, 实际: ${pb1_after_start.currentStats.hp}。`;
                }
            } else {
                detail_8_1 = `未能找到后援甲 (pb1) 或其位置不为后排。位置: ${pb1_after_start ? pb1_after_start.position : '未找到'}`;
            }
            logSubResult("8.1 后排HP恢复", passed_8_1, detail_8_1);


            // 子测试 8.2: 前排阵亡后，满HP的后排单位正确替补
            setupMockData(); // 重新设置数据以隔离测试
            // 创建一个队伍，前排血少，后排一个血不满（但会被回满），一个血满
            let teamForReinforce_8_2 = [
                JSON.parse(JSON.stringify(MockCharacter.characters['pf1'])), // 前锋甲
                JSON.parse(JSON.stringify(MockCharacter.characters['pf2'])), // 前锋乙
                JSON.parse(JSON.stringify(MockCharacter.characters['pb1'])), // 后援甲 (初始不满血)
                JSON.parse(JSON.stringify(MockCharacter.characters['pb2']))  // 后援乙 (初始满血)
            ];
            teamForReinforce_8_2.find(m => m.id === 'pf1').currentStats.hp = 1;
            teamForReinforce_8_2.find(m => m.id === 'pf2').currentStats.hp = 1;
            teamForReinforce_8_2.find(m => m.id === 'pb1').currentStats.hp = 50; // 确保初始不满

            const monsterForReinforce_8_2 = JSON.parse(JSON.stringify(monster1));
            monsterForReinforce_8_2.currentStats.attack = 10; // 确保能打死前排
            MockSkillLoader.skills['skill_attack_single'].effects = [{ type: 'damage', value: 10 }];

            const battleLog_8_2 = [];
            const originalLog_8_2 = battleInstance.logBattle;
            battleInstance.logBattle = (msg) => { battleLog_8_2.push(msg); };
            
            // 传递角色实例数组给 startBattle
            const battleResult_8_2 = battleInstance.startBattle({ members: teamForReinforce_8_2.map(m => m.id) }, monsterForReinforce_8_2, teamForReinforce_8_2);
            battleInstance.logBattle = originalLog_8_2;

            const pb1_final_8_2 = battleResult_8_2.teamMembers.find(m => m.id === 'pb1');
            const pb2_final_8_2 = battleResult_8_2.teamMembers.find(m => m.id === 'pb2');
            let passed_8_2 = false;
            let detail_8_2 = "";

            // 验证至少一个后排成功替补且HP正确
            let backlinerReinforced = false;
            if (pb1_final_8_2 && pb1_final_8_2.position === 'front' && pb1_final_8_2.currentStats.hp === pb1_final_8_2.currentStats.maxHp) {
                backlinerReinforced = true;
                detail_8_2 += `后援甲 (pb1) 成功替补到前排，HP为满 (${pb1_final_8_2.currentStats.hp}/${pb1_final_8_2.currentStats.maxHp})。\n`;
            }
            if (pb2_final_8_2 && pb2_final_8_2.position === 'front' && pb2_final_8_2.currentStats.hp === pb2_final_8_2.currentStats.maxHp) {
                backlinerReinforced = true;
                 detail_8_2 += `后援乙 (pb2) 成功替补到前排，HP为满 (${pb2_final_8_2.currentStats.hp}/${pb2_final_8_2.currentStats.maxHp})。\n`;
            }

            if (backlinerReinforced) {
                passed_8_2 = true;
            } else {
                detail_8_2 += "未能验证后排单位正确替补并恢复满HP。\n";
                if (pb1_final_8_2) detail_8_2 += `pb1 pos: ${pb1_final_8_2.position}, hp: ${pb1_final_8_2.currentStats.hp}/${pb1_final_8_2.currentStats.maxHp}\n`;
                if (pb2_final_8_2) detail_8_2 += `pb2 pos: ${pb2_final_8_2.position}, hp: ${pb2_final_8_2.currentStats.hp}/${pb2_final_8_2.currentStats.maxHp}\n`;
            }
             // 检查前排是否真的都死了
            const pf1_final_8_2 = battleResult_8_2.teamMembers.find(m => m.id === 'pf1');
            const pf2_final_8_2 = battleResult_8_2.teamMembers.find(m => m.id === 'pf2');
            if ((!pf1_final_8_2 || pf1_final_8_2.currentStats.hp <= 0) && (!pf2_final_8_2 || pf2_final_8_2.currentStats.hp <= 0)) {
                detail_8_2 += "前排单位确认已阵亡。\n";
            } else {
                passed_8_2 = false; // 如果前排没死，替补测试就没意义了
                detail_8_2 += "错误：前排单位未全部阵亡，替补测试前提不成立。\n";
                if(pf1_final_8_2) detail_8_2 += ` pf1 HP: ${pf1_final_8_2.currentStats.hp}.\n`;
                if(pf2_final_8_2) detail_8_2 += ` pf2 HP: ${pf2_final_8_2.currentStats.hp}.\n`;
            }
            logSubResult("8.2 后排替补到前排并满HP", passed_8_2, detail_8_2 + "\n战斗日志:\n" + battleLog_8_2.join("\n"));


            // 子测试 8.3: 替补单位能正常参与战斗 (简单验证是否行动)
            let passed_8_3 = false;
            let detail_8_3 = "";
            if (passed_8_2 && backlinerReinforced) { // 只有在替补成功后才进行此测试
                let reinforcedAndActed = false;
                if (pb1_final_8_2 && pb1_final_8_2.position === 'front') {
                    const pb1_acted = battleLog_8_2.some(log => log.includes("后援甲 使用了技能") || log.includes("后援甲 普通攻击"));
                    if (pb1_acted) {
                        reinforcedAndActed = true;
                        detail_8_3 += "后援甲 (pb1) 在替补后成功参与了战斗。\n";
                    } else {
                         detail_8_3 += "后援甲 (pb1) 在替补后未能找到其行动记录。\n";
                    }
                }
                if (pb2_final_8_2 && pb2_final_8_2.position === 'front') {
                     const pb2_acted = battleLog_8_2.some(log => log.includes("后援乙 使用了技能") || log.includes("后援乙 普通攻击"));
                     if (pb2_acted) {
                        reinforcedAndActed = true;
                        detail_8_3 += "后援乙 (pb2) 在替补后成功参与了战斗。\n";
                    } else {
                         detail_8_3 += "后援乙 (pb2) 在替补后未能找到其行动记录。\n";
                    }
                }
                if(reinforcedAndActed) passed_8_3 = true;

            } else {
                detail_8_3 = "由于前序测试失败或无后援替补，跳过此测试。";
            }
            logSubResult("8.3 替补单位参与战斗", passed_8_3, detail_8_3);


            // 子测试 8.4: 战斗结束条件 - 我方全灭 (包括后排)
            setupMockData();
            let team_all_low_hp_8_4 = [ // 使用包含后排的队伍定义
                JSON.parse(JSON.stringify(MockCharacter.characters['pf1'])),
                JSON.parse(JSON.stringify(MockCharacter.characters['pf2'])),
                JSON.parse(JSON.stringify(MockCharacter.characters['pb1'])),
                JSON.parse(JSON.stringify(MockCharacter.characters['pb2']))
            ];
            team_all_low_hp_8_4.forEach(m => m.currentStats.hp = 1); // 所有成员HP都为1

            const monster_strong_8_4 = JSON.parse(JSON.stringify(monster1));
            monster_strong_8_4.currentStats.attack = 100; // 怪物高攻
            MockSkillLoader.skills['skill_attack_single'].effects = [{ type: 'damage', value: 100 }];

            const battleResult_team_wipe_8_4 = battleInstance.startBattle({ members: team_all_low_hp_8_4.map(m=>m.id) }, monster_strong_8_4, team_all_low_hp_8_4);
            let passed_8_4 = false;
            let detail_8_4 = "";
            if (!battleResult_team_wipe_8_4.victory) {
                 const allDead = battleResult_team_wipe_8_4.teamMembers.every(m => m.currentStats.hp <= 0);
                 if (allDead) {
                    passed_8_4 = true;
                    detail_8_4 = "我方全灭 (包括后排)，战斗判定为失败，所有成员HP <= 0。";
                 } else {
                    detail_8_4 = "我方全灭，战斗判定为失败，但并非所有成员HP <= 0。\n";
                    battleResult_team_wipe_8_4.teamMembers.forEach(m => {
                        detail_8_4 += `${m.name} HP: ${m.currentStats.hp}\n`;
                    });
                 }
            } else {
                detail_8_4 = "我方全灭，但战斗判定为胜利。";
            }
            logSubResult("8.4 战斗结束 - 我方全灭 (含后排)", passed_8_4, detail_8_4);

            // 子测试 8.5: 战斗结束条件 - 敌方全灭 (我方有后排但未上场)
            setupMockData();
            let team_normal_hp_8_5 = [ // 使用包含后排的队伍定义
                JSON.parse(JSON.stringify(MockCharacter.characters['pf1'])),
                JSON.parse(JSON.stringify(MockCharacter.characters['pf2'])),
                JSON.parse(JSON.stringify(MockCharacter.characters['pb1'])),
                JSON.parse(JSON.stringify(MockCharacter.characters['pb2']))
            ];
             // 确保前排能打死怪，后排血量正常
            team_normal_hp_8_5.find(m => m.id === 'pf1').currentStats.attack = 100;


            const monster_low_hp_8_5 = JSON.parse(JSON.stringify(monster1));
            monster_low_hp_8_5.currentStats.hp = 1; // 怪物HP为1

            const battleResult_monster_wipe_8_5 = battleInstance.startBattle({ members: team_normal_hp_8_5.map(m=>m.id) }, monster_low_hp_8_5, team_normal_hp_8_5);
            let passed_8_5 = false;
            let detail_8_5 = "";
            if (battleResult_monster_wipe_8_5.victory) {
                if (battleResult_monster_wipe_8_5.monster.currentStats.hp <= 0) {
                    passed_8_5 = true;
                    detail_8_5 = "敌方被击败，战斗判定为胜利，怪物HP <= 0。";
                } else {
                     detail_8_5 = "敌方被击败，战斗判定为胜利，但怪物HP > 0。";
                }
            } else {
                detail_8_5 = "敌方被击败，但战斗判定为失败。";
            }
            logSubResult("8.5 战斗结束 - 敌方全灭 (我方有后排)", passed_8_5, detail_8_5);


            logResult(testName, allSubtestsPassed, subtestDetails);
        }


        // 自动运行测试
        window.onload = function() {
            // 在所有核心脚本加载后，用我们的 Mock 对象覆盖全局对象
            if (typeof Character !== 'undefined') { // 确保原始 Character 已加载
                console.log("onload: 准备覆盖 window.Character。当前 typeof window.Character.getCharacter:", typeof Character.getCharacter);
                window.Character = MockCharacter; // 现在覆盖
                console.log("onload: MockCharacter 已覆盖 window.Character。");
                console.log("onload: 覆盖后 typeof window.Character.getCharacter:", typeof window.Character.getCharacter);
            } else {
                console.error("原始 Character 对象未定义，无法进行 Mock 覆盖。");
                logResult("原始Character对象未定义", false, "测试框架可能无法正常工作。");
                return;
            }
            
            // 确保 battle.js 已加载并 Battle 对象可用
            if (typeof Battle !== 'undefined' && window.Battle) {
                // Wrap Battle methods for logging 'this' context and currentBattle state
                const originalBattleStart = window.Battle.startBattle;
                window.Battle.startBattle = function(...args) {
                    console.log("[TEST WRAPPER] Battle.startBattle called. 'this' === window.Battle?", this === window.Battle);
                    const result = originalBattleStart.apply(this, args);
                    console.log("[TEST WRAPPER] Battle.startBattle finished. 'this.currentBattle' is:", this.currentBattle ? "truthy" : this.currentBattle);
                    console.log("[TEST WRAPPER] window.Battle.currentBattle is:", window.Battle.currentBattle ? "truthy" : window.Battle.currentBattle);
                    return result;
                };

                const originalBattleReset = window.Battle.reset;
                window.Battle.reset = function(...args) {
                    console.log("[TEST WRAPPER] Battle.reset called. 'this' === window.Battle?", this === window.Battle);
                    originalBattleReset.apply(this, args);
                    console.log("[TEST WRAPPER] Battle.reset finished. 'this.currentBattle' is:", this.currentBattle ? "truthy" : this.currentBattle);
                    console.log("[TEST WRAPPER] window.Battle.currentBattle is:", window.Battle.currentBattle ? "truthy" : window.Battle.currentBattle);
                };
                console.log("MockCharacter and Battle method wrappers are set up.");

                // setupMockData(); // runTests 内部会调用 setupMockData
                runTests().catch(err => {
                    logResult("测试执行出错", false, "错误: " + err.message + "\n" + err.stack);
                    console.error("测试执行出错:", err);
                });
            } else {
                logResult("Battle对象未定义", false, "请确保 battle.js 已正确加载。");
                console.error("Battle对象未定义!");
            }
        };
    </script>
    <!-- 引入核心战斗逻辑脚本 -->
    <!-- 注意：这些路径需要根据你的项目结构进行调整 -->
    <!-- 如果这些文件有其他依赖，也需要一并引入 -->
    <script src="src/js/core/battle-logger.js"></script> <!-- BattleLogger 依赖 -->
    <script src="src/js/core/buff-system.js"></script>
    <script src="src/js/core/skill-loader.js"></script> <!-- SkillLoader 依赖于此 -->
    <script src="src/js/core/job-system.js"></script> <!-- JobSystem 依赖于此 -->
    <script src="src/js/core/job-skills.js"></script> <!-- JobSkills 依赖于此 -->
    <script src="src/js/core/character.js"></script> <!-- Character 依赖于此 -->
    <script>
        // 在 battle.js 加载前，尝试破坏原始 Character.getCharacter
        // 以便 battle.js 内部的检查逻辑会用它自己的简单版本覆盖它
        // 这个简单版本会从 this.characters 读取，而 this 在调用时会是我们的 MockCharacter
        if (window.Character && typeof window.Character.getCharacter === 'function') {
            console.log("[PRE-BATTLE-LOAD HACK] Temporarily setting window.Character.getCharacter to null.");
            window.Character.getCharacter = null;
        }
    </script>
    <script src="src/js/core/battle.js"></script>
</body>
</html>